filter_positions <- function(purpose, position_taken) {
if (is.null(position_taken)) {
return(subset(protests, sub(" .*", "", Event..legacy..see.tags.) == purpose))
}
return(data.frame(subset(protests, Event..legacy..see.tags. == paste0(purpose, " (", position_taken, ")"))))
}
#                                         Note 18.
# 6c: Demonstrate that your two functions, filter_protests() and
#    and filter_and_report(), work correctly. Comment on your tests.
#    For example, do your functions have limitations? Or, do they
#    work perfectly? If so, how do you know> Do think these two
#    functions are useful? What might you do next if you had more time?
wa <- filter_positions("Racial Injustice", NULL)
#                                         Note 18.
# 6c: Demonstrate that your two functions, filter_protests() and
#    and filter_and_report(), work correctly. Comment on your tests.
#    For example, do your functions have limitations? Or, do they
#    work perfectly? If so, how do you know> Do think these two
#    functions are useful? What might you do next if you had more time?
wa <- filter_positions("Racial Injustice", "Violence")
#                                         Note 18.
# 6c: Demonstrate that your two functions, filter_protests() and
#    and filter_and_report(), work correctly. Comment on your tests.
#    For example, do your functions have limitations? Or, do they
#    work perfectly? If so, how do you know> Do think these two
#    functions are useful? What might you do next if you had more time?
wa <- filter_positions("Racial Injustice", NULL)
# filter_positions() should return a dataframe of the protests that match on `purpose`
# and `position_taken`. If `position_taken` is NULL then all protests that
# match the `purpose` should be returned.
filter_positions <- function(purpose, position_taken) {
#                                         Note 18.
# 6c: Demonstrate that your two functions, filter_protests() and
#    and filter_and_report(), work correctly. Comment on your tests.
#    For example, do your functions have limitations? Or, do they
#    work perfectly? If so, how do you know> Do think these two
#    functions are useful? What might you do next if you had more time?
wa <- filter_positions("Racial Injustice", NULL)
# filter_positions() should return a dataframe of the protests that match on `purpose`
# and `position_taken`. If `position_taken` is NULL then all protests that
# match the `purpose` should be returned.
filter_positions <- function(purpose, position_taken) {
if (is.null(position_taken)) {
return(subset(protests, Event..legacy..see.tags. == sub(" .*", "", purpose)))
}
return(data.frame(subset(protests, Event..legacy..see.tags. == paste0(purpose, " (", position_taken, ")"))))
}
#                                         Note 18.
# 6c: Demonstrate that your two functions, filter_protests() and
#    and filter_and_report(), work correctly. Comment on your tests.
#    For example, do your functions have limitations? Or, do they
#    work perfectly? If so, how do you know> Do think these two
#    functions are useful? What might you do next if you had more time?
wa <- filter_positions("Racial Injustice", NULL)
# filter_positions() should return a dataframe of the protests that match on `purpose`
# and `position_taken`. If `position_taken` is NULL then all protests that
# match the `purpose` should be returned.
filter_positions <- function(purpose, position_taken) {
if (is.null(position_taken) == TRUE) {
return(subset(protests, Event..legacy..see.tags. == sub(" .*", "", purpose)))
}
return(data.frame(subset(protests, Event..legacy..see.tags. == paste0(purpose, " (", position_taken, ")"))))
}
#                                         Note 18.
# 6c: Demonstrate that your two functions, filter_protests() and
#    and filter_and_report(), work correctly. Comment on your tests.
#    For example, do your functions have limitations? Or, do they
#    work perfectly? If so, how do you know> Do think these two
#    functions are useful? What might you do next if you had more time?
wa <- filter_positions("Racial Injustice", NULL)
#                                         Note 18.
# 6c: Demonstrate that your two functions, filter_protests() and
#    and filter_and_report(), work correctly. Comment on your tests.
#    For example, do your functions have limitations? Or, do they
#    work perfectly? If so, how do you know> Do think these two
#    functions are useful? What might you do next if you had more time?
wa <- filter_positions("Racial Injustice", "Violence")
# filter_positions() should return a dataframe of the protests that match on `purpose`
# and `position_taken`. If `position_taken` is NULL then all protests that
# match the `purpose` should be returned.
filter_positions <- function(purpose, position_taken) {
if (is.null(position_taken)) {
return(subset(protests, Event..legacy..see.tags. == sub(" .*", "", purpose)))
}
return(data.frame(subset(protests, Event..legacy..see.tags. == paste0(purpose, " (", position_taken, ")"))))
}
#                                         Note 18.
# 6c: Demonstrate that your two functions, filter_protests() and
#    and filter_and_report(), work correctly. Comment on your tests.
#    For example, do your functions have limitations? Or, do they
#    work perfectly? If so, how do you know> Do think these two
#    functions are useful? What might you do next if you had more time?
wa <- filter_positions("Racial Injustice", "Violence")
#                                         Note 18.
# 6c: Demonstrate that your two functions, filter_protests() and
#    and filter_and_report(), work correctly. Comment on your tests.
#    For example, do your functions have limitations? Or, do they
#    work perfectly? If so, how do you know> Do think these two
#    functions are useful? What might you do next if you had more time?
wa <- filter_positions("Racial Injustice", NULL)
# filter_positions() should return a dataframe of the protests that match on `purpose`
# and `position_taken`. If `position_taken` is NULL then all protests that
# match the `purpose` should be returned.
filter_positions <- function(purpose, position_taken) {
if (is.null(position_taken)) {
return(subset(protests, Event..legacy..see.tags. == sub(" .*", "", purpose)))
}
return(data.frame(subset(protests, Event..legacy..see.tags. == paste0(purpose, " (", position_taken, ")"))))
}
#                                         Note 18.
# 6c: Demonstrate that your two functions, filter_protests() and
#    and filter_and_report(), work correctly. Comment on your tests.
#    For example, do your functions have limitations? Or, do they
#    work perfectly? If so, how do you know> Do think these two
#    functions are useful? What might you do next if you had more time?
wa <- filter_positions("Racial Injustice", NULL)
#                                         Note 18.
# 6c: Demonstrate that your two functions, filter_protests() and
#    and filter_and_report(), work correctly. Comment on your tests.
#    For example, do your functions have limitations? Or, do they
#    work perfectly? If so, how do you know> Do think these two
#    functions are useful? What might you do next if you had more time?
wa <- filter_positions("Racial Injustice", "Violence")
# filter_positions() should return a dataframe of the protests that match on `purpose`
# and `position_taken`. If `position_taken` is NULL then all protests that
# match the `purpose` should be returned.
filter_positions <- function(purpose, position_taken) {
if (is.null(position_taken)) {
return(subset(protests, Event..legacy..see.tags. == sub(" .*", "", purpose)))
}
return(data.frame(subset(protests, Event..legacy..see.tags. == paste0(purpose, " (", position_taken, ")"))))
}
View(wa)
View(wa)
View(wa)
# filter_positions() should return a dataframe of the protests that match on `purpose`
# and `position_taken`. If `position_taken` is NULL then all protests that
# match the `purpose` should be returned.
filter_positions <- function(purpose, position_taken) {
if (is.null(position_taken)) {
return(subset(protests, Event..legacy..see.tags. == sub(" .*", "", purpose)))
}
return(data.frame(subset(protests, Event..legacy..see.tags. == paste0(purpose, " (", position_taken, ")"))))
}
#                                         Note 18.
# 6c: Demonstrate that your two functions, filter_protests() and
#    and filter_and_report(), work correctly. Comment on your tests.
#    For example, do your functions have limitations? Or, do they
#    work perfectly? If so, how do you know> Do think these two
#    functions are useful? What might you do next if you had more time?
wa <- filter_positions("Racial Injustice", "Violence")
# filter_positions() should return a dataframe of the protests that match on `purpose`
# and `position_taken`. If `position_taken` is NULL then all protests that
# match the `purpose` should be returned.
filter_positions <- function(purpose, position_taken) {
if (is.null(position_taken)) {
return(subset(protests, sub(" .*", "", Event..legacy..see.tags.) == purpose))
}
return(data.frame(subset(protests, Event..legacy..see.tags. == paste0(purpose, " (", position_taken, ")"))))
}
#                                         Note 18.
# 6c: Demonstrate that your two functions, filter_protests() and
#    and filter_and_report(), work correctly. Comment on your tests.
#    For example, do your functions have limitations? Or, do they
#    work perfectly? If so, how do you know> Do think these two
#    functions are useful? What might you do next if you had more time?
wa <- filter_positions("Racial Injustice", NULL)
print(wa)
#                                         Note 18.
# 6c: Demonstrate that your two functions, filter_protests() and
#    and filter_and_report(), work correctly. Comment on your tests.
#    For example, do your functions have limitations? Or, do they
#    work perfectly? If so, how do you know> Do think these two
#    functions are useful? What might you do next if you had more time?
wa <- filter_positions("Racial Injustice", "Violence")
return(subset(protests, str_detect(Event..legacy..see.tags., pattern = purpose)))
# filter_positions() should return a dataframe of the protests that match on `purpose`
# and `position_taken`. If `position_taken` is NULL then all protests that
# match the `purpose` should be returned.
filter_positions <- function(purpose, position_taken) {
if (is.null(position_taken)) {
return(subset(protests, str_detect(Event..legacy..see.tags., pattern = purpose)))
}
return(data.frame(subset(protests, Event..legacy..see.tags. == paste0(purpose, " (", position_taken, ")"))))
}
#                                         Note 18.
# 6c: Demonstrate that your two functions, filter_protests() and
#    and filter_and_report(), work correctly. Comment on your tests.
#    For example, do your functions have limitations? Or, do they
#    work perfectly? If so, how do you know> Do think these two
#    functions are useful? What might you do next if you had more time?
wa <- filter_positions("Racial Injustice", NULL)
#                                         Note 03.
# 1a: Load the `stringr` package, which you will use later.
library(stringr)
# 1b: Load the data from https://countlove.org/data/data.csv (Variable: `protests`)
protests <- read.csv("https://countlove.org/data/data.csv")
#                                         Note 04.
#     *BEST PRACTICE:* Use View() to open and examine the dataset. Some key questions to ask:
#        1. What information is available?
#        2. Are there missing values (NA, which means "Not Available.") or odd values?
#        3. What are the column names (sometimes called variables or features)?
View(protests)
# 1c: Use an R function to determine how many protests are in the dataset? (Variable: `num_protests`)
num_protests <- nrow(protests)
# 1d: Use an R function to determine how many how many values (also known as
#    attributes or features) have been recorded for each protest (Variable: `num_features`)
num_features <- ncol(protests)
# 2a: Extract the `Attendees` column into a variable called `num_attendees`. (Variable: `num_attendees`)
num_attendees <- protests$Attendees
#                                         Note 06.
#     For the following prompts, you will need to consider missing values. In R,
#     missing values are denoted by the symbol NA, which means "Not Available."
omitted_attendees <- na.omit(num_attendees)
# 2b: What is the lowest number of attendees? (Variable: `min_attendees`)
min_attendees <- min(omitted_attendees)
# 1c: Use an R function to determine how many protests are in the dataset? (Variable: `num_protests`)
num_protests <- nrow(protests)
# 1d: Use an R function to determine how many how many values (also known as
#    attributes or features) have been recorded for each protest (Variable: `num_features`)
num_features <- ncol(protests)
# 2a: Extract the `Attendees` column into a variable called `num_attendees`. (Variable: `num_attendees`)
num_attendees <- protests$Attendees
#                                         Note 06.
#     For the following prompts, you will need to consider missing values. In R,
#     missing values are denoted by the symbol NA, which means "Not Available."
omitted_attendees <- na.omit(num_attendees)
# 2b: What is the lowest number of attendees? (Variable: `min_attendees`)
min_attendees <- min(omitted_attendees)
# 2c: What is the highest number of attendees? (Variable: `max_attendees`)
max_attendees <- max(omitted_attendees)
# 2d: What is the mean number of attendees? (Variable: `mean_attendees`)
mean_attendees <- mean(omitted_attendees)
# 2e: What is the median number of attendees? (Variable: `median_attendees`)
median_attendees <- median(omitted_attendees)
# 2f: What is the difference between the mean and median number of attendees? (Variable: `mean_median_diff`)
mean_median_diff <- mean_attendees - median_attendees
# 2g: To further assess the distribution of values, create a boxplot of the
#    number of attendees using the `boxplot()` function. Store the plot in a
#    variable called `attendees_distribution`. (Note: Later in the course, we
#    will use more refined plotting methods.) (Variable: `attendees_distribution`)
attendees_distribution <- boxplot(omitted_attendees)
# 2h: Create another boxplot of the *log* of the number of attendees.
#    Store the plot in a variable `log_attendees_distribution`. (Note: You will
#    likely see see a warning in the console, which is expected.) (Variable: `log_attendess_distribution`)
log_attendees_distribution <- boxplot(omitted_attendees, log = "y")
# 3a: Extract the `Location` column. (Variable: `locations`)
locations <- protests$Location
# 3b: How many *unique* locations are in the dataset? (Variable: `num_locations`)
num_locations <- unique(locations)
# 3c: How many protests occurred in Washington State (WA)? (Hint: Use a function,
#    called str_detect(), from the stringr package (see https://stringr.tidyverse.org/),
#    to detect the presence (or absence) of WA".) (Variable: `num_in_wa`)
num_in_wa <- sum(str_detect(locations, pattern = "WA"), na.rm = TRUE)
# 3d: What proportion of protests occurred in Washington? (Variable: `prop_in_wa`)
prop_in_wa <- num_in_wa / length(locations)
count_in_location <- function(location) {
location_count = sum(str_detect(locations, pattern = location), na.rm = TRUE)
if (location_count > 0) {
return(paste0("There were ", location_count, " protests in ", location, "."))
}
return(paste("Location", location, "not found."))
}
# 3f: Use your function above to compute the number of protests in "Washington, DC". (Variable: `dc_summary`)
dc_summary <- count_in_location("Washington, DC")
# 3g: Use your function above to compute the number of protests in "Minneapolis". (Variable: `minneapolis_summary`)
minneapolis_summary <- count_in_location("Minneapolis")
# 3h: Use your function above to demonstrate that it works correctly for a
#    location that is not in the data set. (Variable: `missing_summary`)
missing_summary <- count_in_location("Krypton")
# 3i: Create a new vector `states` that holds the state locations, that is, the
#    last two characters of each value in the `locations` vector. (Hint: You may
#    want to again use a function from the `stringr` package
#    Check, for example, the `str_sub()` function.) (Variable: `states`)
states <- str_trim(str_sub(num_locations, -3, -1), side = "left")
# 3j: Create a vector of the unique states in your dataset. (Variable: `uniq_states`)
uniq_states <- unique(states)
# 3k: Create a summary sentence for each state by passing your `uniq_states`
#    variable and `count_in_location` variables to the `sapply()` function.
#    (Hint: Study section 8.3 in the textbook. It is important to understand
#    the `sapply()` and `lapply()` functions.) (Variable: `state_summary`)
sapply(uniq_states, count_in_location)
# 3l: Create a summary table by passing your `states` variable to the
#    `table()` function and by storing the result in the variable `state_table`.
state_table <- table(states)
#
#    *SUGGESTION:* Use the View() function to more easily examine the table. (Variable: `state_table`)
View(state_table)
# 3m: What was the maximum number of protests in a state? (Hint: Use the
#    `state_table` variable.) (Variable: `max_in_state`)
max_in_state <- max(state_table)
# 4a: Extract the `Date` column into a variable called `dates` by passing the
#    column to the `as.Date()` function. (Note: The `as.Date()` function will
#    process the values as dates, which are *fortunately* already in an optimal
#    format for parsing.) (Variable: `dates`)
dates <- as.Date(protests$Date)
# 4b: What is the most recent date in the dataset? (Variable: `most_recent`)
most_recent <- max(dates)
# 4c: What is the earliest date in the dataset? (Variable: `earliest`)
earliest <- min(dates)
# 4d: What is the length of the time span of the dataset? (Hint: R can do math with
#    dates pretty well by default!) (Variable: `time_span`)
time_span <- most_recent - earliest
# 4e: Create a vector of the dates that are in 2020. (Variable: `in_2020`)
in_2020 <- dates[dates >= "2020-01-01" & dates <= "2020-12-31"]
# 4f: Create a vector of the dates that are in 2019. (Variable: `in_2019`)
in_2019 <- dates[dates >= "2019-01-01" & dates <= "2019-12-31"]
# 4g: What is the ratio of the number of protests in 2020 compared to 2019? (Variable: `ratio_2020_2019`)
ratio_2020_2019 <- length(in_2020) / length(in_2019)
# 4h: Write a function `count_on_date()` that accepts the parameter `date`,
#    and returns the sentence:
#       "There were N protests on DATE." - where
#           N is the number of protests on that date; and
#           DATE is the date provided. (Variable: `count_on_date`)
count_on_date <- function(date) {
return(paste0("There were ", sum(str_detect(dates, date)), " protests on ", date, "."))
}
# 4i: Using your function you just wrote, how many protests were there on
#    May 24th, 2020? (Variable: `num_on_may_24`)
num_on_may_24 <- count_on_date("2020-05-24")
# 4j: Using your function you just wrote, how many protests were there on
#    May 31th, 2020? (Variable: `num_on_may_31`)
num_on_may_31 <- count_on_date("2020-05-31")
# 4k: How many protests occurred each month in 2020? (Hint: Use the `months()`
#    function, your `in_2020` dates, and the `table()` function. If you like, you
#    can do this in multiple steps.) (Variable: `by_month_table`)
by_month_table <- table(months(in_2020))
# 4l: As a comparison, let's assess the change between July 2019 and July 2020.
#    What is the *difference* in the number of protests between July 2020 and
#    July 2019? You'll want to do this in multiple steps as you see fit, though
#    your answer should be stored in the variable. (Variable: `change_july_protests`)
table_2019 <- table(months(in_2019))
change_july_protests <- by_month_table["July"] - table_2019["July"]
# 5a: Extract the `Event..legacy..see.tags.` column into a variable called `purpose`.
#
#    *CONSIDER:* The name of this column, "Event..legacy..see.tags.", is very odd. Why?
#    What can be learned from this column name? (Variable: `purpose`)
purpose <- protests$Event..legacy..see.tags.
# 5b: How many different purposes are listed in the dataset? (Variable: `num_purposes`)
num_purposes <- unique(purpose)
# 5c: That's quite a few! Why are there so many purposes? Type `print(purpose)` to
#    examine the values in the vector. You will notice a common pattern. Here, for
#    example, are the first six elements:
#         [1] "Healthcare"
#         [2] "Civil Rights"
#         [3] "Environment"
#         [4] "Other (Martin Luther King Jr.)"
#         [5] "Healthcare (Pro-Planned Parenthood)"
#         [6] "Executive"
print(purpose)
#    (https://stringr.tidyverse.org/). To do so, you will need to write a regular
#    expression that matches " (blah blah)" and replaces it with the empty string (`""`).
#    Note: The space before the left parenthesis needs to be matched too.
#
#    Write a function, `get_purposes()`, that returns a vector of high-level
#    purposes. Your function will take no parameters.
#
#    To solve this problem, you might do a web search and/or find an introduction
#    to regular expressions and R. Take your time. You will likely need to do some
#    thoughtful trial and error. (Variable: `get_purposes`)
get_purposes <- function() {
sub(" .*", "", purpose)
}
# 5d: Show that your function, `get_purposes()` works. (Variable: `high_level_purpose`)
high_level_purpose <- get_purposes()
# 5e: How many "high level" purposes have you identified? (Variable: `num_high_level`)
num_high_level <- length(unique(get_purposes()))
# 5f: Use the table() function to count the number of protests for each high level purpose. (Variable: `high_level_table`)
high_level_table <- table(high_level_purpose)
#                                         Note 15.
#     *CONSIDER:* Use View() to examine your `high_level_table` variable. What
#     picture does this paint of the U.S.?
View(high_level_table)
format_doc <- function(protest_df, purpose, position_taken=NULL) {
# Heading components
heading1 <- paste("# Protest purpose: ", purpose, "\n")
heading2 <- "\n"
if (!is.null(position_taken)) {
heading2 <- paste("## Position taken: ", position_taken, "\n")
}
# Summary component
num_protests <- format(nrow(protest_df), big.mark=",")
total_attendees <- format(sum(protest_df$Attendees, na.rm=TRUE), big.mark=",")
summary <- paste0("_Summary_\n\n",
"* Number of Protests: ", num_protests, "\n",
"* Total Attendees: ", total_attendees, "\n\n",
"_List of Protests (Attendees)_\n\n")
# List of protests component (Note: Bullet_list is a vector)
bullet_list <- paste0("* ", protest_df$Date, ": ", protest_df$Location,
" [Article](", protest_df$Source, ")", " (_", protest_df$Attendees, "_)\n")
# Collapse the vector into a string
url_str <- paste0(bullet_list, collapse="")
# Paste together each of the report components
md_doc <- paste0(heading1, heading2, summary, url_str)
return(md_doc)
}
# A helper function to write the report to a file
# NOTE: Check and update the filename for your machine
write_report <- function(md_doc, fname="~/Documents/info201/reports/report.md") {
output_fn <- file(fname, "w")
writeLines(md_doc, output_fn)
close(output_fn)
}
# filter_positions() should return a dataframe of the protests that match on `purpose`
# and `position_taken`. If `position_taken` is NULL then all protests that
# match the `purpose` should be returned.
filter_positions <- function(purpose, position_taken) {
if (is.null(position_taken)) {
return(subset(protests, str_detect(Event..legacy..see.tags., pattern = purpose)))
}
return(data.frame(subset(protests, Event..legacy..see.tags. == paste0(purpose, " (", position_taken, ")"))))
}
# This function filters the data into a dataframe and formats
# the data into a markdown document.
# Parameters:
#   purpose: purpose of the protests
#   position_taken: specific position of the protest
filter_and_report <- function(purpose, position_taken) {
sub_set_protests = data.frame(filter_positions(purpose, position_taken))
format_doc(sub_set_protests, purpose, position_taken)
}
#                                         Note 18.
# 6c: Demonstrate that your two functions, filter_protests() and
#    and filter_and_report(), work correctly. Comment on your tests.
#    For example, do your functions have limitations? Or, do they
#    work perfectly? If so, how do you know> Do think these two
#    functions are useful? What might you do next if you had more time?
wa <- filter_positions("Racial Injustice", NULL)
#                                         Note 18.
# 6c: Demonstrate that your two functions, filter_protests() and
#    and filter_and_report(), work correctly. Comment on your tests.
#    For example, do your functions have limitations? Or, do they
#    work perfectly? If so, how do you know> Do think these two
#    functions are useful? What might you do next if you had more time?
filtered_data <- filter_positions("Racial Injustice", NULL)
#                                         Note 18.
# 6c: Demonstrate that your two functions, filter_protests() and
#    and filter_and_report(), work correctly. Comment on your tests.
#    For example, do your functions have limitations? Or, do they
#    work perfectly? If so, how do you know> Do think these two
#    functions are useful? What might you do next if you had more time?
filtered_position_null <- filter_positions("Racial Injustice", NULL)
filtered_data <- filter_positions("Racial Injustice", "Violence")
View(filtered_position_null)
filter_and_report("Racial Injustice", "Violence")
# A helper function to write the report to a file
# NOTE: Check and update the filename for your machine
write_report <- function(md_doc, fname="~/Documents/INFO201/reports/report.md") {
output_fn <- file(fname, "w")
writeLines(md_doc, output_fn)
close(output_fn)
}
filter_and_report("Racial Injustice", "Violence")
# A helper function to write the report to a file
# NOTE: Check and update the filename for your machine
write_report <- function(md_doc, fname="~/INFO201/reports/report.md") {
output_fn <- file(fname, "w")
writeLines(md_doc, output_fn)
close(output_fn)
}
filter_and_report("Racial Injustice", "Violence")
# A helper function to write the report to a file
# NOTE: Check and update the filename for your machine
write_report <- function(md_doc, fname="/INFO201/reports/report.md") {
output_fn <- file(fname, "w")
writeLines(md_doc, output_fn)
close(output_fn)
}
filter_and_report("Racial Injustice", "Violence")
# A helper function to write the report to a file
# NOTE: Check and update the filename for your machine
write_report <- function(md_doc, fname="/INFO201/report.md") {
output_fn <- file(fname, "w")
writeLines(md_doc, output_fn)
close(output_fn)
}
filter_and_report("Racial Injustice", "Violence")
# A helper function to write the report to a file
# NOTE: Check and update the filename for your machine
write_report <- function(md_doc, fname="INFO201/report.md") {
output_fn <- file(fname, "w")
writeLines(md_doc, output_fn)
close(output_fn)
}
filter_and_report("Racial Injustice", "Violence")
View(wa)
View(wa)
View(protests)
View(protests)
View(attendees_distribution)
View(log_attendees_distribution)
View(log_attendees_distribution)
# 5b: How many different purposes are listed in the dataset? (Variable: `num_purposes`)
num_purposes <- unique(purpose)
# 5c: That's quite a few! Why are there so many purposes? Type `print(purpose)` to
#    examine the values in the vector. You will notice a common pattern. Here, for
#    example, are the first six elements:
#         [1] "Healthcare"
#         [2] "Civil Rights"
#         [3] "Environment"
#         [4] "Other (Martin Luther King Jr.)"
#         [5] "Healthcare (Pro-Planned Parenthood)"
#         [6] "Executive"
print(purpose)
# 5e: How many "high level" purposes have you identified? (Variable: `num_high_level`)
num_high_level <- length(unique(get_purposes()))
# 5f: Use the table() function to count the number of protests for each high level purpose. (Variable: `high_level_table`)
high_level_table <- table(high_level_purpose)
#                                         Note 15.
#     *CONSIDER:* Use View() to examine your `high_level_table` variable. What
#     picture does this paint of the U.S.?
View(high_level_table)
